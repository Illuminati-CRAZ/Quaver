/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Copyright (c) Swan & The Quaver Team <support@quavergame.com>.
*/

using System;
using System.Linq;
using System.Collections.Generic;
using Quaver.API.Enums;
using Quaver.API.Helpers;
using Quaver.API.Maps;
using Quaver.Shared.Config;
using Quaver.Shared.Screens.Gameplay.Rulesets.Keys.HitObjects;
using Wobble.Logging;

namespace Quaver.Shared.Screens.Gameplay.Rulesets.Keys.Playfield.Lines
{
    public class TimingLineManager
    {
        /// <summary>
        ///     Timing Line object pool.
        /// </summary>
        private Queue<TimingLine> Pool { get; set; }

        /// <summary>
        ///     Timing Line information. Generated by this class with qua object.
        /// </summary>
        private Queue<TimingLineInfo> CachedInfo { get; set; }

        /// <summary>
        ///     Queue that timing line information is dequeued from. Resets to a copy of <see cref="Info"/> on object pool (re)initialization.
        /// </summary>
        private Queue<TimingLineInfo> Info { get; set; }

        /// <summary>
        ///     Reference to the HitObjectManager
        /// </summary>
        public HitObjectManagerKeys HitObjectManager { get; }

        /// <summary>
        ///     Reference to the current Ruleset
        /// </summary>
        public GameplayRulesetKeys Ruleset { get; }

        /// <summary>
        ///     Initial size for the object pool
        /// </summary>
        private int InitialPoolSize { get; } = 6;

        /// <summary>
        ///     The Scroll Direction of every Timing Line
        /// </summary>
        public ScrollDirection ScrollDirection { get; }

        /// <summary>
        ///     Target position when TrackPosition = 0
        /// </summary>
        private float TrackOffset { get; }

        /// <summary>
        ///     Size of every Timing Line
        /// </summary>
        private float SizeX { get; }

        /// <summary>
        ///     Position of every Timing Line
        /// </summary>
        private float PositionX { get; }

        /// <summary>
        ///
        /// </summary>
        /// <param name="map"></param>
        /// <param name="ruleset"></param>
        public TimingLineManager(GameplayRulesetKeys ruleset, ScrollDirection direction, float targetY, float size, float offset)
        {
            TrackOffset = targetY;
            SizeX = size;
            PositionX = offset;
            ScrollDirection = direction;
            Ruleset = ruleset;
            HitObjectManager = (HitObjectManagerKeys)ruleset.HitObjectManager;
            GenerateTimingLineInfo(ruleset.Map);
            InitializeObjectPool();
        }

        /// <summary>
        ///     Generate Timing Line Information for the map
        /// </summary>
        /// <param name="map"></param>
        public void GenerateTimingLineInfo(Qua map)
        {
            // generate base timing lines
            var originalLines = new List<TimingLineInfo>();

            for (var i = 0; i < map.TimingPoints.Count; i++)
            {
                if (map.TimingPoints[i].Hidden)
                    continue;

                // Get target position and increment
                // Target position has tolerance of 1ms so timing points dont overlap by chance
                var target = i + 1 < map.TimingPoints.Count ? map.TimingPoints[i + 1].StartTime - 1 : map.Length;

                var signature = (int)map.TimingPoints[i].Signature;

                // Max possible sane value for timing lines
                const float maxBpm = 9999f;

                var msPerBeat = 60000 / Math.Min(Math.Abs(map.TimingPoints[i].Bpm), maxBpm);
                var increment = signature * msPerBeat;

                // ReSharper disable once CompareOfFloatsByEqualityOperator
                if (increment <= 0)
                    continue;

                // Initialize timing lines between current timing point and target position
                for (var songPos = map.TimingPoints[i].StartTime; songPos < target; songPos += increment)
                {
                    var offset = HitObjectManager.GetPositionFromTime(songPos);

                    originalLines.Add(new TimingLineInfo(songPos, offset));
                }
            }

            // make copies of a line for each time show up during gameplay
            var lines = new List<TimingLineInfo>();

            foreach (var line in originalLines)
            {
                (var exactTimes, var timeIntervals) = HitObjectManager.GetTimesFromPosition(line.TrackOffset);
                var times = exactTimes.Union(timeIntervals.Select(x => x.Item2)).Distinct().OrderBy(x => x);

                const float EPSILON = 1;

                // easily filter out some unnecessary ones
                var temp = new List<float>();
                foreach (var time in times)
                {
                    // don't need to make a copy of the original line
                    if (Math.Abs(time - line.StartTime) < EPSILON)
                        continue;

                    // irrelevant
                    if (time < 0)
                        continue;

                    temp.Add(time);
                }

                // use this time instead of the copy's because of floating point rounding errors
                int index = HitObjectManager.FindIntervalIndex(temp, line.StartTime);
                Logger.Debug($"Inserting at {index + 1}", LogType.Runtime);
                temp.Insert(index + 1, line.StartTime);

                LinkedList<float> linkedTimes = new LinkedList<float>(temp);

                Logger.Debug(String.Join(", ", linkedTimes), LogType.Runtime);

                // further filtering

                // remove copies that don't unload before later copies load
                var current = linkedTimes.Last;
                while (current.Previous != null)
                {
                    float start = current.Previous.Value;
                    float end = current.Value;

                    (int i, int j) = HitObjectManager.FindItemIndicesInInterval(map.SliderVelocities.Select(x => x.StartTime).ToList(), start, end);

                    // check if no position markers
                    if (i == -1 || j == -1)
                    {
                        Logger.Debug("Removed " + current.Previous.Value, LogType.Runtime);
                        linkedTimes.Remove(current.Previous);
                        continue;
                    }

                    var positionMarkers = HitObjectManager.VelocityPositionMarkers.GetRange(i, j - i + 1);

                    // remove earlier line if it's recycle threshold isn't reached before the later line
                    var maxDelta = Math.Max(Math.Abs(positionMarkers.Max() - line.TrackOffset),
                                            Math.Abs(positionMarkers.Min() - line.TrackOffset));

                    if (maxDelta < HitObjectManager.RecycleObjectPositionThreshold)
                    {
                        Logger.Debug("Removed " + current.Previous.Value, LogType.Runtime);
                        linkedTimes.Remove(current.Previous);
                        continue;
                    }

                    current = current.Previous;
                }

                // remove copies that load within time threshold of later copy
                // current = linkedTimes.Last;
                // while (current.Previous != null)
                // {

                // }

                // debugging
                const int offset = 1000;
                int counter = 0;

                lines.AddRange(linkedTimes.Select(time => new TimingLineInfo(time, line.TrackOffset + offset * counter++)));
            }

            // Sort lines by time
            CachedInfo = new Queue<TimingLineInfo>(lines.OrderBy(x => x.StartTime));
        }

        /// <summary>
        ///     Initialize the Timing Line Object Pool
        /// </summary>
        public void InitializeObjectPool()
        {
            if (Pool != null)
            {
                while (Pool.Count > 0)
                    Pool.Dequeue().Destroy();
            }

            Pool = new Queue<TimingLine>();
            Info = new Queue<TimingLineInfo>(CachedInfo);

            // skip unnecessary timing lines
            while (Info.Count > 0 && Info.Peek().StartTime < HitObjectManager.CurrentAudioPosition)
            {
                Info.Dequeue();
            }
        }

        /// <summary>
        ///     Update every object in the Timing Line Object Pool and create new objects if necessary
        /// </summary>
        public void UpdateObjectPool()
        {
            // Update line positions
            if (Pool.Count > 0)
            {
                foreach (var line in Pool)
                    line.UpdateSpritePosition(HitObjectManager.CurrentTrackPosition);
            }

            // Recycle necessary pool objects
            while (Pool.Count > 0 && Pool.Peek().Info.StartTime < HitObjectManager.CurrentAudioPosition &&
                   Math.Abs(Pool.Peek().CurrentTrackPosition) > HitObjectManager.RecycleObjectPositionThreshold)
            {
                var line = Pool.Dequeue();

                if (Info.Count > 0)
                {
                    line.Info = Info.Dequeue();
                    line.UpdateSpritePosition(HitObjectManager.CurrentTrackPosition);
                    Pool.Enqueue(line);
                }
                else
                {
                    line.Destroy(); // prevents freezing when repeatedly skipping to line art in cherry blossoms
                }
            }

            // Create new pool objects if they are in range
            while (Info.Count > 0 && (Math.Abs(Info.Peek().TrackOffset - HitObjectManager.CurrentTrackPosition) < HitObjectManager.CreateObjectPositionThreshold ||
                   Info.Peek().StartTime - HitObjectManager.CurrentAudioPosition < HitObjectManager.CreateObjectTimeThreshold))
            {
                CreatePoolObject(Info.Dequeue());
            }
        }

        /// <summary>
        ///     Create and add new Timing Line Object to the Object Pool
        /// </summary>
        /// <param name="info"></param>
        private void CreatePoolObject(TimingLineInfo info)
        {
            var line = new TimingLine(Ruleset, info, ScrollDirection, TrackOffset, SizeX, PositionX);
            line.UpdateSpritePosition(HitObjectManager.CurrentTrackPosition);
            Pool.Enqueue(line);
        }
    }
}
